// Code generated by genset. DO NOT EDIT.

// vim: syntax=go

package stringset

import (
	"fmt"
	"math/rand"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func init() {
	rand.Seed(time.Now().Unix())
}

// Assert existence of item getter function for use in tests. If your tests
// fail here, you need to define the function NewSetItem and have
// it return a new instance of the item type string in your set, so the
// tests have content to manipulate in the Set.
var _ = NewSetItem

func getSetItems(n int) []string {
	items := make([]string, n)
	for i := 0; i < n; i++ {
		items[i] = NewSetItem()
	}

	return items
}

func AssertSetElementsMatch(t assert.TestingT, expected []string, set Set) (ok bool) {
	if h, ok := t.(interface {
		Helper()
	}); ok {
		h.Helper()
	}
	return assert.ElementsMatch(t, expected, set.Slice())
}

func RequireSetElementsMatch(t require.TestingT, expected []string, set Set) {
	if h, ok := t.(interface {
		Helper()
	}); ok {
		h.Helper()
	}
	require.ElementsMatch(t, expected, set.Slice())
}

func TestSetNew(t *testing.T) {
	t.Run("New creates an empty set", func(t *testing.T) {
		s := NewSet()
		assert.Equal(t, 0, s.Count())
	})

	t.Run("Items passed to New are added to the Set", func(t *testing.T) {
		items := getSetItems(3)
		s := NewSet(items...)
		require.Equal(t, 3, s.Count())
		assert.True(t, s.Has(items[0]))
		assert.True(t, s.Has(items[1]))
		assert.True(t, s.Has(items[2]))
	})
}

func TestSetAdd(t *testing.T) {
	t.Run("Add adds items to an existing Set", func(t *testing.T) {
		s := NewSet()
		items := getSetItems(3)

		s.Add(items[0])
		s.Add(items[1:]...)
		require.Equal(t, 3, s.Count())
		assert.True(t, s.Has(items[0]))
		assert.True(t, s.Has(items[1]))
		assert.True(t, s.Has(items[2]))
		AssertSetElementsMatch(t, items, s)
	})

	t.Run("Add initialises an uninitialised Set", func(t *testing.T) {
		var s Set
		items := getSetItems(3)
		s.Add(items[0])
		s.Add(items[1])
		s.Add(items[2])
		require.Equal(t, 3, s.Count())
		assert.True(t, s.Has(items[0]))
		assert.True(t, s.Has(items[1]))
		assert.True(t, s.Has(items[2]))
		AssertSetElementsMatch(t, items, s)
	})
}

func TestSetCount(t *testing.T) {
	t.Run("Count returns 0 on an empty uninitialised Set", func(t *testing.T) {
		var s Set
		require.Equal(t, 0, s.Count())
	})

	t.Run("Count returns the number of items in the Set", func(t *testing.T) {
		var s Set
		n := rand.Intn(2048) + 100
		for i := 0; i < n; i++ {
			assert.Equal(t, i, s.Count())
			s.Add(getSetItems(1)[0])
			assert.Equal(t, i+1, s.Count())
		}
		require.Equal(t, n, s.Count())
	})
}

func TestSetHas(t *testing.T) {
	t.Run("Has returns false when called on an uninitialised Set", func(t *testing.T) {
		var s Set
		require.False(t, s.Has(getSetItems(1)[0]))
	})

	t.Run("Has returns true for an item previously added to the Set and false otherwise", func(t *testing.T) {
		var s Set

		type setTestItem struct {
			dt      string
			include bool
		}

		// Generate some random items (integers) to add to the set and
		// others not to add but use in checking
		n := rand.Intn(2048) + 100
		items := make([]setTestItem, n)
		for i := 0; i < n; i++ {
			items[i] = setTestItem{
				dt:      getSetItems(1)[0],
				include: rand.Int31()&0x01 == 0x01,
			}
		}

		// add the items to the set
		for _, item := range items {
			if item.include {
				s.Add(item.dt)
			}
		}

		for _, item := range items {
			assert.Equal(t, item.include, s.Has(item.dt))
		}
	})
}

func TestSetRemove(t *testing.T) {
	t.Run("Remove returns cleanly on an uninitialised Set", func(t *testing.T) {
		var s Set
		s.Remove(getSetItems(1)[0])
		require.Equal(t, 0, s.Count())
		AssertSetElementsMatch(t, nil, s)
	})

	t.Run("Remove removes an item previously added to the Set s.t. Has(item) returns false", func(t *testing.T) {
		var s Set
		items := getSetItems(5)
		s.Add(items...)
		require.Equal(t, 5, s.Count())
		s.Remove(items[2])
		require.Equal(t, 4, s.Count())
		require.False(t, s.Has(items[2]))

		expectItems := append(items[:2], items[3:]...)
		for _, expectItem := range expectItems {
			require.True(t, s.Has(expectItem))
		}

		RequireSetElementsMatch(t, expectItems, s)
	})

	t.Run("Remove is a no-op for an element not in the set", func(t *testing.T) {
		var s Set
		items := getSetItems(3)
		s.Add(items...)
		require.Equal(t, 3, s.Count())
		s.Remove(getSetItems(1)[0])
		require.Equal(t, 3, s.Count())
		RequireSetElementsMatch(t, items, s)
	})
}

func TestSetSlice(t *testing.T) {
	t.Run("Slice on an uninitialised Set returns slice of length 0", func(t *testing.T) {
		var s Set
		require.Equal(t, 0, len(s.Slice()))
	})

	t.Run("Slice returns a list of items in the Set", func(t *testing.T) {
		var s Set
		items := getSetItems(5)
		s.Add(items...)
		sl := s.Slice()
		assert.ElementsMatch(t, items, sl)
	})
}

func TestSetString(t *testing.T) {
	tcs := [][]string{
		{},
		getSetItems(5),
		getSetItems(1),
	}

	const offset = len(`Set`)
	for _, tc := range tcs {
		s := strings.TrimSpace(NewSet(tc...).String())
		assert.Equal(t, "Set{", s[:offset+1])
		assert.Equal(t, '}', rune(s[len(s)-1]))

		contents := s[offset+1 : len(s)-1]
		var parts []string
		if contents != "" {
			parts = strings.Split(contents, ", ")
		}
		strElts := make([]string, 0, len(tc))
		for _, elt := range tc {
			strElts = append(strElts, fmt.Sprintf("%v", elt))
		}
		assert.ElementsMatch(t, strElts, parts)
	}
}

type testSetCase struct {
	leftElements, rightElements, expect []string
}

func appendTestSetCase(testCases []testSetCase, left, right, expect []string) []testSetCase {
	return append(testCases, testSetCase{
		leftElements:  append(left[:0:0], left...),
		rightElements: append(right[:0:0], right...),
		expect:        append(expect[:0:0], expect...),
	})
}

func intersectTestCasesSet() []testSetCase {
	var testCases []testSetCase
	app := appendTestSetCase
	n := getSetItems

	testCases = append(testCases, []testSetCase{{
		leftElements:  nil,
		rightElements: nil,
		expect:        nil,
	}, {
		leftElements:  n(5),
		rightElements: nil,
		expect:        nil,
	}, {
		leftElements:  nil,
		rightElements: n(5),
		expect:        nil,
	}, {
		leftElements:  []string{},
		rightElements: n(1),
		expect:        []string{},
	}, {
		leftElements:  n(1),
		rightElements: []string{},
		expect:        []string{},
	}, {
		leftElements:  []string{},
		rightElements: []string{},
		expect:        []string{},
	}}...)

	// We require persistent values in the following, so they require more computation
	// to avoid any randomness in the new item factory
	{
		onlyOne := n(1)
		testCases = app(testCases, onlyOne, onlyOne, onlyOne)
	}
	{
		moreLeft := n(3)
		thanRight := moreLeft[:2]
		testCases = app(testCases, moreLeft, thanRight, thanRight)
	}
	{
		// More than one, same left-right
		sameMultipleLeftRight := n(2)
		testCases = app(testCases, sameMultipleLeftRight, sameMultipleLeftRight, sameMultipleLeftRight)
	}
	{
		twoLeft := n(2)
		oneRight := twoLeft[1:]
		testCases = app(testCases, twoLeft, oneRight, oneRight)
	}

	return testCases
}

func unionTestCasesSet() []testSetCase {
	var testCases []testSetCase
	app := appendTestSetCase
	n := getSetItems

	testCases = append(testCases, []testSetCase{{
		leftElements:  nil,
		rightElements: nil,
		expect:        nil,
	}, {
		leftElements:  []string{},
		rightElements: []string{},
		expect:        []string{},
	}}...)

	// We require access to the same generated values in both arms of the
	// test in the following, so they require computation to workaround
	// randomness in the new item generator
	{
		onlyLeft := n(5)
		testCases = app(testCases, onlyLeft, nil, onlyLeft)
	}
	{
		onlyRight := n(5)
		testCases = app(testCases, nil, onlyRight, onlyRight)
	}
	{
		onlyOneLeft := n(1)
		testCases = app(testCases, onlyOneLeft, nil, onlyOneLeft)
	}
	{
		onlyOneRight := n(1)
		testCases = app(testCases, nil, onlyOneRight, onlyOneRight)
	}
	{
		multipleLeft := n(3)
		emptyRight := n(0)
		testCases = app(testCases, multipleLeft, emptyRight, multipleLeft)
	}
	{
		sameLeftRight := n(5)
		testCases = app(testCases, sameLeftRight, sameLeftRight, sameLeftRight)
	}
	{
		emptyLeft := n(0)
		multipleRight := n(3)
		testCases = app(testCases, emptyLeft, multipleRight, multipleRight)
	}
	{
		onlyOneLeftRight := n(1)
		testCases = app(testCases, onlyOneLeftRight, onlyOneLeftRight, onlyOneLeftRight)
	}
	{
		differentLeft := n(5)
		right := n(5)
		testCases = app(testCases, differentLeft, right, append(differentLeft, right...))
	}
	{
		someLeft := n(5)
		overlapRight := append(someLeft[3:], n(2)...)
		testCases = app(testCases, someLeft, overlapRight, append(someLeft[0:3], overlapRight...))
	}

	return testCases
}

func subtractTestCasesSet() []testSetCase {
	var testCases []testSetCase
	app := appendTestSetCase
	n := getSetItems

	testCases = append(testCases, []testSetCase{{
		leftElements:  nil,
		rightElements: nil,
		expect:        nil,
	}, {
		leftElements:  []string{},
		rightElements: []string{},
		expect:        []string{},
	}, {
		leftElements:  nil,
		rightElements: n(5),
		expect:        nil,
	}, {
		leftElements:  []string{},
		rightElements: n(5),
		expect:        []string{},
	}}...)

	// We require access to the same generated values in both arms of the
	// test in the following, so they require computation to workaround
	// randomness in the new item generator
	{
		onlyLeft := n(5)
		testCases = app(testCases, onlyLeft, nil, onlyLeft)
	}
	{
		onlyOneLeft := n(1)
		testCases = app(testCases, onlyOneLeft, nil, onlyOneLeft)
	}
	{
		multipleLeft := n(3)
		emptyRight := n(0)
		testCases = app(testCases, multipleLeft, emptyRight, multipleLeft)
	}
	{
		sameLeftRight := n(5)
		testCases = app(testCases, sameLeftRight, sameLeftRight, []string{})
	}
	{
		onlyOneLeftRight := n(1)
		testCases = app(testCases, onlyOneLeftRight, onlyOneLeftRight, []string{})
	}
	{
		differentLeft := n(5)
		right := n(4)
		testCases = app(testCases, differentLeft, right, differentLeft)
	}
	{
		someLeft := n(5)
		overlapRight := make([]string, 0, 6)
		overlapRight = append(overlapRight, someLeft[4], someLeft[3], someLeft[2])
		overlapRight = append(overlapRight, n(3)...)
		testCases = app(testCases, someLeft, overlapRight, someLeft[:2])
	}

	return testCases
}

// makeSet initialises and returns a Set with the items provided in xs. If xs
// is nil, the Set is returned uninitialised.
func makeSetForTest(t *testing.T, xs []string) Set {
	var s Set
	if xs != nil {
		s.Add(xs...)
	}
	require.Equal(t, len(xs), s.Count())
	return s
}

func testSetOperation(t *testing.T, cases []testSetCase,
	op func(s1 *Set, s2 Set),
) {
	t.Helper()

	for i, tc := range cases {
		t.Logf("testing case %d: %s", i, tc)

		s1 := makeSetForTest(t, tc.leftElements)
		s2 := makeSetForTest(t, tc.rightElements)

		op(&s1, s2)

		// s2 is unmodified
		RequireSetElementsMatch(t, tc.rightElements, s2)

		// s1 has been modified appropriately
		RequireSetElementsMatch(t, tc.expect, s1)
	}
}

func TestSetIntersection(t *testing.T) {
	testSetOperation(t, intersectTestCasesSet(), func(s1 *Set, s2 Set) {
		s1.Intersect(s2)
	})
}

func TestSetUnion(t *testing.T) {
	testSetOperation(t, unionTestCasesSet(), func(s1 *Set, s2 Set) {
		s1.Union(s2)
	})

}

func TestSetSubtract(t *testing.T) {
	testSetOperation(t, subtractTestCasesSet(), func(s1 *Set, s2 Set) {
		s1.Subtract(s2)
	})
}

func testNonMutatingSetOperation(cases []testSetCase, op func(s1, s2 Set) Set) func(*testing.T) {
	return func(t *testing.T) {
		for _, tc := range cases {
			s1 := makeSetForTest(t, tc.leftElements)
			s2 := makeSetForTest(t, tc.rightElements)

			out := op(s1, s2)

			// The input sets are not modified
			require.Equal(t, len(tc.leftElements), s1.Count())
			require.ElementsMatch(t, tc.leftElements, s1.Slice())
			require.Equal(t, len(tc.rightElements), s2.Count())
			require.ElementsMatch(t, tc.rightElements, s2.Slice())

			require.Equal(t, len(tc.expect), out.Count())
			require.ElementsMatch(t, tc.expect, out.Slice())
		}
	}
}

func TestIntersectionSet(t *testing.T) {
	testNonMutatingSetOperation(intersectTestCasesSet(), IntersectSet)(t)
}

func TestUnionSet(t *testing.T) {
	testNonMutatingSetOperation(unionTestCasesSet(), UnionSet)(t)
}

func TestSubtractSet(t *testing.T) {
	testNonMutatingSetOperation(subtractTestCasesSet(), SubtractSet)(t)
}
