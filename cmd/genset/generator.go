// vim: set tw=120

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/mhuxtable/go-set/cmd/genset/templates"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

func main() {
	opts := options{
		fileName:  "zz_genset.go",
		setName:   "Set",
		withTests: false,
	}

	cmd := cobra.Command{
		// TODO(MH) convert DIRECTORY to be a package path (and make module aware)
		Use:  "genset DATATYPE DIRECTORY",
		Args: cobra.ExactArgs(2),
		RunE: func(_ *cobra.Command, args []string) error {
			return run(args, opts)
		},
	}
	opts.AddFlags(cmd.Flags())

	if err := cmd.Execute(); err != nil {
		log.Fatalf("Error while running command: %s", err)
	}
}

func run(args []string, opts options) error {
	dataType := args[0]
	var outputDir string

	{
		var err error
		outputDir, err = filepath.Abs(args[1])
		if err != nil {
			return fmt.Errorf("while resolving output directory: %w", err)
		}
	}

	if !strings.HasSuffix(opts.fileName, ".go") {
		return fmt.Errorf("output filename does not have suffix .go: %s", opts.fileName)
	}

	if !IsIdentifier(opts.setName) {
		return fmt.Errorf("cannot use %s as set name, as it is not a valid identifier", opts.setName)
	}

	if stat, err := os.Stat(outputDir); err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("output path %s does not exist", outputDir)
		}

		return fmt.Errorf("while getting information about output path: %w", err)
	} else {
		if !stat.IsDir() {
			return fmt.Errorf("output path %s is not a directory", outputDir)
		}
	}

	if opts.packageName == "" {
		opts.packageName = filepath.Base(outputDir)
	}

	m := model{
		PackageName:         opts.packageName,
		DataType:            dataType,
		SetTypeName:         opts.setName,
		InternalSetTypeName: internalTypeName(opts.setName, dataType),
	}

	{
		outPath := filepath.Join(outputDir, opts.fileName)
		err := generateToFile(templates.Set, outPath, m)
		if err != nil {
			return err
		}
	}

	if opts.withTests {
		filename := strings.TrimSuffix(opts.fileName, ".go") + "_test.go"
		outPath := filepath.Join(outputDir, filename)
		err := generateToFile(templates.SetTest, outPath, m)
		if err != nil {
			return err
		}
	}

	return nil
}

func internalTypeName(setName, dataType string) string {
	// swap out any characters in the data type name to form a valid identifier for the internal set type name
	internalTypeName := "_set_" + setName + "_"
	if IsIdentifier(dataType) {
		internalTypeName += dataType
	} else {
		internalTypeName += strings.Map(func(r rune) rune {
			if unicode.IsLetter(r) || unicode.IsDigit(r) {
				return r
			}
			return '_'
		}, dataType)
	}

	return internalTypeName
}

type options struct {
	fileName, packageName, setName string
	withTests                      bool
}

func (opts *options) AddFlags(fs *pflag.FlagSet) {
	fs.StringVar(&opts.fileName, "filename", opts.fileName, "Output filename. This file will be truncated if it exists.")
	fs.StringVar(&opts.packageName, "package-name", opts.packageName,
		"Go package name for the generated set, defaults to last element of output directory if omitted")
	fs.StringVar(&opts.setName, "set-name", opts.setName, "Name of the generated Set datatype")
	fs.BoolVar(&opts.withTests, "generate-tests", opts.withTests, "Generate tests for the Set. (You must supply an item getter function.)")
}

type generator struct {
	options
	outputDirectory, dataType string
}

type model struct {
	PackageName         string
	DataType            string
	SetTypeName         string
	InternalSetTypeName string
}

func generateGoFromTemplate(tpl *template.Template, m model) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("// File generated by genset. DO NOT EDIT.\n\n")

	if err := tpl.Execute(&buf, m); err != nil {
		return nil, fmt.Errorf("while generating Go source code: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Input source code was:\n\n%s\n\n", buf.Bytes())
		return nil, fmt.Errorf("while formatting Go source code: %w", err)
	}

	return formatted, nil
}

func generateToFile(tpl *template.Template, filename string, m model) error {
	code, err := generateGoFromTemplate(tpl, m)
	if err != nil {
		return fmt.Errorf("while generating Go source code for set: %w", err)
	}

	if err = ioutil.WriteFile(filename, code, 0644); err != nil {
		return fmt.Errorf("while emitting generated source code to %s: %w", filename, err)
	}

	fmt.Println(filename)
	return nil
}
