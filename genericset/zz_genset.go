// File generated by genset. DO NOT EDIT.

// vim: syntax=go

package genericset

//go:generate genset --filename "zz_genset.go" --package-name "genericset" --set-name "Set" --generate-tests=true --generate-comment=true --quiet=true interface{} .

import (
	"fmt"
	"reflect"
	"strings"
)

type _set_Set_interface__ map[interface{}]struct{}

// Set is a basic set data structure for elements of type interface{}. It is
// not safe for concurrent use. Where appropriate, it is the user's
// responsibility to ensure type safety for elements retrieved from the set.
type Set struct {
	// embed set to hide the underlying map
	_set_Set_interface__
}

// New instantiates and returns a new Set with the provided initial elements.
func NewSet(x ...interface{}) Set {
	var s Set
	for _, item := range x {
		s.Add(item)
	}
	return s
}

// Add adds the provided element(s) to the Set.
func (s *_set_Set_interface__) Add(xs ...interface{}) {
	if len(xs) == 0 {
		return
	}

	if *s == nil {
		*s = make(_set_Set_interface__)
	}

	for _, x := range xs {
		(*s)[x] = struct{}{}
	}
}

// Count returns the number of elements in the Set.
func (s Set) Count() int {
	if s._set_Set_interface__ == nil {
		return 0
	}
	return len(s._set_Set_interface__)
}

// Has returns whether the Set contains the specified element.
func (s Set) Has(x interface{}) bool {
	if len(s._set_Set_interface__) == 0 {
		return false
	}

	_, exists := (s._set_Set_interface__)[x]
	return exists
}

// Remove removes the specified element from the Set. This is a no-op if the
// Set does not contain the element.
func (s *_set_Set_interface__) Remove(x interface{}) {
	if *s == nil {
		return
	}

	delete(*s, x)
}

// Slice returns a slice of the elements contained in the Set.
func (s Set) Slice() []interface{} {
	sl := make([]interface{}, 0, len(s._set_Set_interface__))
	for k := range s._set_Set_interface__ {
		sl = append(sl, k)
	}
	return sl
}

// String implements fmt.Stringer
func (s Set) String() string {
	str := make([]string, 0, len(s._set_Set_interface__))
	for el := range s._set_Set_interface__ {
		str = append(str, fmt.Sprintf("%v", el))
	}
	return fmt.Sprintf("Set{%s}", strings.Join(str, ", "))
}

// Intersect computes the set intersection of sets s1 and s2, leaving the
// result in set s1.
func (s1 *_set_Set_interface__) Intersect(s2 Set) {
	for k := range *s1 {
		if !s2.Has(k) {
			delete(*s1, k)
		}
	}
}

// Union computes the set union of sets s1 and s2, leaving the result in set s1.
func (s1 *_set_Set_interface__) Union(s2 Set) {
	s1.Add(s2.Slice()...)
}

// Subtract subtracts set s2 from set s1, mutating the set s1 in-place.
func (s1 *_set_Set_interface__) Subtract(s2 Set) {
	for k := range *s1 {
		if s2.Has(k) {
			delete(*s1, k)
		}
	}
}

// Intersect returns the set intersection of sets s1 and s2 in a new Set,
// without mutating the input Sets.
func IntersectSet(s1, s2 Set) Set {
	if s1.Count() == 0 || s2.Count() == 0 {
		return Set{}
	}

	var s Set
	for _, el := range s1.Slice() {
		if s2.Has(el) {
			s.Add(el)
		}
	}
	return s
}

// Union returns the set union of sets s1 and s2 in a new Set, without mutating
// the input Sets.
func UnionSet(s1, s2 Set) Set {
	if s1.Count() == 0 && s2.Count() == 0 {
		return Set{}
	}

	var s Set
	s.Add(s1.Slice()...)
	s.Add(s2.Slice()...)
	return s
}

// Subtract returns the subtraction of set s2 from set s1 in a new Set, without
// mutating the input Sets.
func SubtractSet(s1, s2 Set) Set {
	if s1.Count() == 0 {
		return Set{}
	}
	if s2.Count() == 0 {
		return s1
	}

	var s Set
	s.Add(s1.Slice()...)
	s.Subtract(s2)
	return s
}
